diff --git a/src/endpoints/grpc/grpc.h b/src/endpoints/grpc/grpc.h
index b08e37ff9..0e192c82e 100644
--- a/src/endpoints/grpc/grpc.h
+++ b/src/endpoints/grpc/grpc.h
@@ -67,22 +67,31 @@ namespace ccf::grpc
     }
     else
     {
-      const auto message_length = impl::read_message_frame(data, size);
-      if (size != message_length)
+      In in;
+      try
       {
-        throw std::logic_error(fmt::format(
-          "Error in gRPC frame: frame size is {} but messages is {} bytes",
-          size,
-          message_length));
-      }
+        const auto message_length = impl::read_message_frame(data, size);
 
-      In in;
-      if (!in.ParseFromArray(data, message_length))
+        if (size != message_length)
+        {
+          throw std::logic_error(fmt::format(
+            "Error in gRPC frame: frame size is {} but messages is {} bytes",
+            size,
+            message_length));
+        }
+
+        if (!in.ParseFromArray(data, message_length))
+        {
+          throw std::logic_error(fmt::format(
+            "Error deserialising protobuf payload of type {}, size {}",
+            in.GetTypeName(),
+            size));
+        }
+      }
+      catch (const std::exception& e)
       {
-        throw std::logic_error(fmt::format(
-          "Error deserialising protobuf payload of type {}, size {}",
-          in.GetTypeName(),
-          size));
+        // Note: Client streaming!
+        LOG_FAIL_FMT("Error deserialising payload: {}", e.what());
       }
       return in;
     }
diff --git a/src/http/http2_callbacks.h b/src/http/http2_callbacks.h
index 8d169946b..e232c99ec 100644
--- a/src/http/http2_callbacks.h
+++ b/src/http/http2_callbacks.h
@@ -29,12 +29,17 @@ namespace http2
     auto& body = stream_data->outgoing.body.ro_data();
     size_t to_read = std::min(body.size(), length);
 
+    LOG_TRACE_FMT(
+      "http2::read_outgoing_callback, stream: {} - to read {} bytes",
+      stream_id,
+      to_read);
+
     if (
       to_read == 0 &&
       stream_data->outgoing.state == StreamResponseState::Streaming)
     {
       // Early out: when streaming, avoid calling this callback
-      // repeatedly when there no data to read
+      // repeatedly when there is no data to read
       return NGHTTP2_ERR_DEFERRED;
     }
 
@@ -82,8 +87,20 @@ namespace http2
           return 0;
         }
 
+        auto& headers = stream_data->incoming.headers;
+        std::string url = {};
+        {
+          const auto url_it = headers.find(http2::headers::PATH);
+          if (url_it != headers.end())
+          {
+            url = url_it->second;
+          }
+        }
+
         // If the request is complete, process it
-        if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM)
+        if (
+          frame->hd.flags & NGHTTP2_FLAG_END_STREAM ||
+          url == "/etcdserverpb.Watch/Watch")
         {
           auto* p = get_parser(user_data);
           p->handle_completed(stream_id, stream_data);
diff --git a/src/http/http2_parser.h b/src/http/http2_parser.h
index f9c0469b7..ae856db94 100644
--- a/src/http/http2_parser.h
+++ b/src/http/http2_parser.h
@@ -292,8 +292,10 @@ namespace http2
 
       if (stream_data->outgoing.state != StreamResponseState::Uninitialised)
       {
-        throw std::logic_error(fmt::format(
-          "Stream {} should be uninitialised to start stream", stream_id));
+        LOG_FAIL_FMT("Stream already started");
+        return;
+        // throw std::logic_error(fmt::format(
+        //   "Stream {} should be uninitialised to start stream", stream_id));
       }
 
       stream_data->outgoing.state = StreamResponseState::Streaming;
